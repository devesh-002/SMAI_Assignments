# -*- coding: utf-8 -*-
# """2020115003_A1_Q1(1).ipynb

# Automatically generated by Colaboratory.

# Original file is located at
#     https://colab.research.google.com/drive/1laSlhMV0vFViIvgzi_i-XNVBFciKTMq3

# # Assignment 1
# ## Question `1` (K-Nearest Neighbour)

# | | |
# |-|-|
# | Course | Statistical Methods in AI |
# | Release Date | `19.01.2023` |
# | Due Date | `29.01.2023` |

# ### Instructions:
# 1.   Assignment must be implemented using python notebook only (Colab , VsCode , Jupyter etc.)
# 2.   You are allowed to use libraries for data preprocessing (numpy, pandas, nltk etc) and for algorithms as well (sklearn etc). You are not however allowed to directly use classifier models.
# 3.   The performance of the model will hold weightage but you will also be graded largely for data preprocessing steps , explanations , feature selection for vectors etc.
# 4.   Strict plagiarism checking will be done. An F will be awarded for plagiarism.

# ### The Dataset
# The dataset is avaible in the zip file which is a collection of *11099 tweets*. The data will be in the form of a csv file. The ground truth is also given in the zip file which corresponds to whether a tweet was popular or not. Since the task involves selecting features yourself to vectorize a tweet , we suggest some data analysis of the columns you consider important.
# <br><br>

# ### The Task
# You have to build a classifier which can predict the popularity of the tweet, i.e , if the tweet was popular or not. You are required to use **KNN** algorithm to build the classifier and cannot use any inbuilt classifier. All columns are supposed to be analyzed , filtered and preprocessed to determine its importance as a feature in the vector for every tweet (Not every column will be useful).<br>
# The Data contains the **raw text of the tweet**(in the text column) as well as other **meta data** like likes count , user followers count. Note that it might be useful to **create new columns** with useful information. For example, *number of hashtags* might be useful but is not directly present as a column.<br>
# There are 3 main sub parts:
# 1. *Vectorize tweets using only meta data* - likes , user followers count , and other created data
# 2. *Vectorize tweets using only it's text*. This segment will require NLP techniques to clean the text and extract a vector using a BoW model. Here is a useful link for the same - [Tf-Idf](https://towardsdatascience.com/text-vectorization-term-frequency-inverse-document-frequency-tfidf-5a3f9604da6d). Since these vectors will be very large , we recommend reducing their dimensinality (~10 - 25). Hint: [Dimentionality Reduction](https://jonathan-hui.medium.com/machine-learning-singular-value-decomposition-svd-principal-component-analysis-pca-1d45e885e491). Please note that for this also you are allowed to use libraries.

# 3. *Combining the vectors from above two techinques to create one bigger vector*
# <br>


# Using KNN on these vectors build a classifier to predict the popularity of the tweet and report accuracies on each of the three methods as well as analysis. You can use sklearn's Nearest Neighbors and need not write KNN from scratch. (However you cannot use the classifier directly). You are expected to try the classifier for different number of neighbors and identify the optimal K value.

# ## Import necessary libraries
# """

import pandas as pd
import numpy as np
import json
import matplotlib.pyplot as plt
from sklearn.preprocessing import normalize
from collections import Counter
from sklearn.metrics import accuracy_score
from sklearn.metrics import confusion_matrix
from sklearn.metrics import classification_report

"""## Load and display the data"""

#your code here
df = pd.read_csv('/content/Tweets.csv')
df

df_truth = pd.read_csv('/content/ground_truth.csv')
df_truth.columns = ['Ground Truth']
df_truth['Ground Truth'] = df_truth['Ground Truth'].astype('int')
df_truth

"""## Exploratory Data Analysis
*This is an ungraded section but is recommended to get a good grasp on the dataset*
"""

df.info()

df.describe()

# your code here
df.dropna(inplace = True) # none found
x = df.duplicated()
for i in x:
    if(int(i) == 1):
        print(i) # no duplicates found

"""### Adding new columns"""

df['entities'] = df['entities'].apply(lambda x: eval(x))
# print(df['entities'][0].keys(), df['entities'][0].values())
hashtags = list()
for i in df['entities']:
    hashtags.append(len(i['hashtags']))
    
df['hashtags'] = hashtags
df

df['metadata'] = df['metadata'].apply(lambda x: eval(x))
metadata = df['metadata']
print(metadata[0].keys())
print(metadata[0].values())
# iso_language_code is same as lang column

d_lang = dict()
for i in df['lang']:
    if i not in d_lang.keys():
        d_lang[i] = 1
    else:
        d_lang[i] += 1
        
# print(d_lang)
lang_mod = []
for i in df['lang']:
    lang_mod.append(d_lang[i])

df['lang_mod'] = lang_mod
df

df.columns

"""## Part-1
*Vectorize tweets using only meta data*
"""

def get_features(df, df_truth):
    # """
    # Function to return a matrix of dimensions (number of tweets, number of chosen features)
    # Input parameters to this funcion are to be chosen as per requirement (Example: Loaded dataframe of the dataset) 
    # """

    # your code here
    new_df = df.drop(['created_at', 'id', 'id_str', 'text', 'truncated', 'entities', 'metadata', 'source', 'lang', 'user_name', 'user_screen_name', 'user_created_at'], axis=1)
    print(new_df.columns)
    x = new_df.to_numpy()
    y = df_truth.to_numpy()
    return x,y
    
    
X,y = get_features(df, df_truth)
print(X[0])
print(y[1])

print(len(X), len(y))

# """Perform KNN using the vector obtained from get_features() function. Following are the steps to be followed:
# 1. Normalise the vectors
# 2. Split the data into training and test to estimate the performance.
# 3. Fit the Nearest Neughbiurs module to the training data and obtain the predicted class by getting the nearest neighbours on the test data.
# 4. Report the accuracy, chosen k-value and method used to obtain the predicted class. Hint: Plot accuracies for a range of k-values. 
# """

# your code here
X = normalize(X)
X

from sklearn.model_selection import train_test_split
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=37)
print(len(X_train), len(X_test))

class KNN():
    def __init__(self, k=3, p=2):
        self.k = k
        self.p = p
        
    def distance(self, point):
        # return top k least distances of given point from all the points
        arr = list()
        for i in range(len(self.X)):
            dist = sum(abs(self.X[i] - point)**self.p)
            dist = dist**(1/self.p)
            arr.append([i,dist])
          
        arr = sorted(arr, key = lambda x: x[1])
        return arr[0:self.k]
    
    def classifier(self, arr):
        class_arr = [y_train[i[0]][0] for i in arr]
        return Counter(class_arr).most_common(1)[0][0]
    
    def fit(self, X, y):
        self.X = X
        self.y = y
        
    def predict(self, X):
        y_pred = np.empty(X.shape[0])
        
        for ind, i in enumerate(X):
            arr = self.distance(i)
            y_pred[ind] = self.classifier(arr)
            if(ind % 100 == 0):
                print(ind)
        return y_pred

knn = KNN()
knn.fit(X_train, y_train)

y_pred = knn.predict(X_test)
acc = accuracy_score(y_test, y_pred)
acc

# """### experimenting for different values of k"""

k = np.arange(1,50)
accuracy = list()
for i in k:
    knn = KNN(k = i)
    knn.fit(X_train, y_train)
    y_pred = knn.predict(X_test)
    acc = accuracy_score(y_test, y_pred)
    accuracy.append(acc)
    
plt.plot(k, accuracy)
plt.xLabel('K')
plt.yLabel('Accuracy')
plt.show()

# """### experimenting for different values of p"""

p = np.arange(1,10)
accuracy = list()
for i in p:
    knn = KNN()
    knn.fit(X_test)
    acc = accuracy_score(y_test, y_pred)
    accuracy.appendnd(acc)
    
plt.plot(k, accuracy)
plt.xLabel('K')
plt.yLabel('Accuracy')
plt.show()

# """## Part-2
# Vectorize tweets based on the text. More details and reference links can be checked on the Tasks list in the start of the notebook
# """

# !pip install PyStemmer

import nltk
from nltk.corpus import stopwords
from nltk.stem.porter import *
from Stemmer import Stemmer
import re

try:
    nltk.download('stopwords')
except:
    pass
stop_words = set(stopwords.words('english'))
stop_words.add('rt')
stemmer = Stemmer('porter')

def tokenise(text):
    text = text.lower()
    text = re.sub(r'&nbsp;|&lt;|&gt;|&amp;|&quot;|&apos;', r' ', text) # removing html entities
    text = re.sub(r'http[s]?\S*[\s | \n]', r' ', text) # removing links
    text = re.sub("(#[A-Za-z0-9]+)|(@[A-Za-z0-9]+)|([^0-9A-Za-z \t])|(\w+:\/\/\S+)","",text) # removing tags and hashtags
    text = re.split(r'[^A-Za-z0-9]+', text)
    final = ''
    for i in text:
        word = stemmer.stemWord(i)
        if word not in stop_words:
            word += ' '
            final += word
    return final

from math import log2
from collections import defaultdict
from sklearn.decomposition import PCA

def BoW(tweets):
    d = dict()
    l = len(tweets)
    for ind, words in enumerate(tweets):
        words = re.split(r'[^A-Za-z0-9]+', words)
        for i in words:
            if i not in d.keys():
                d[i] = set()
            d[i].add(ind)
    for i in d.keys():
        d[i] = log2(l / len(d[i]))
    word_set = list(d.keys())
    return d, word_set

def tdf(tweets, word_set):
    x = list()
    d = dict()
    for i in word_set:
        d[i] = 0
    for ind, words in enumerate(tweets):
        words = re.split(r'[^A-Za-z0-9]+', words)
        for i in words:
            d[i] += 1
        d = {k: v / total for total in (sum(d.values(), 0.0),) for k,v in d.items()}
        x.append(list(d.values()))
        d = d.fromkeys(d, 0)
    return x

def tf_idf(word_docs, tdf_arr, word_set):
    for ind, doc in enumerate(tdf_arr):
        for ind2, word in enumerate(doc):
            if word != 0:
                idf = word_docs[word_set[ind2]]
                tdf_arr[ind][ind2] *= idf
        if(ind %100 == 0):
          print(ind)
            
    return tdf_arr

def tweet_vectoriser(tweets):
    # """
    # Funtion to return a matrix of dimensions (number of tweets, number of features extracted per tweet)
    # Following are the steps for be followed:
    # 1. Remove links, tags and hashtags from each tweet.
    # 2. Apply TF-IDF on the tweets to extract a vector. 
    # 3. Perform dimensionality reduction on the obtained vector. 
    # Input parameters to this funcion are to be chosen as per requirement (Example: Array of tweets) 
    # """
    # your code here
    for ind, i in enumerate(tweets): # tokenise
        i = tokenise(i)
        tweets[ind] = i
        
    word_docs, word_set = BoW(tweets)
    
    tdf_arr = tdf(tweets, word_set)
    tdf_arr = tf_idf(word_docs, tdf_arr, word_set)
#     final_vector = list()
#     for ind, i in enumerate(tdf_arr):
#         final_vector.append(list(i.values()))
        
#     return np.array(tdf_arr)
    return tdf_arr
        
    

tweets = df['text'].to_list()

# print(tweets[:10], end = '\n\n')
tdf_arr = tweet_vectoriser(tweets)
# final_vector = tweet_vectoriser(tweets)
# final_vector[:5]

print(len(tdf_arr))

# """Perform KNN using the vector obtained from tweet_vectoriser() function. Following are the steps to be followed:

# 1. Normalise the vectors
# 2. Split the data into training and test to estimate the performance.
# 3. Fit the Nearest Neughbiurs module to the training data and obtain the predicted class by getting the nearest neighbours on the test data.
# 4. Report the accuracy, chosen k-value and method used to obtain the predicted class. Hint: Plot accuracies for a range of k-values.
# """

# your code here
from sklearn.decomposition import PCA
tdf_arr = np.array(tdf_arr)
y = df_truth.to_numpy()
tdf_arr = normalize(tdf_arr)

# dimensionality reduction
pca = PCA(n_components=20)
pca.fit(tdf_arr)
tdf_arr = pca.transform(tdf_arr)
print(tdf_arr.shape)

X_train, X_test, y_train, y_test = train_test_split(tdf_arr, y, test_size=0.2, random_state=37)
print(len(X_train), len(X_test))

knn = KNN()
knn.fit(X_train, y_train)

y_pred = knn.predict(X_test)
acc = accuracy_score(y_test, y_pred)
acc

# """### experimenting for different values of k"""

k = np.arange(1,50)
accuracy = list()
for i in k:
    knn = KNN(k = i)
    knn.fit(X_train, y_train)
    y_pred = knn.predict(X_test)
    acc = accuracy_score(y_test, y_pred)
    accuracy.append(acc)
    
plt.plot(k, accuracy)
plt.xLabel('K')
plt.yLabel('Accuracy')
plt.show()

# """## Part-3
# ### Subpart-1

# Combine both the vectors obtained from the tweet_vectoriser() and get_features()
# """

# your code here
X

tdf_arr

X = np.concatenate((X, tdf_arr), axis=1)

print(X.shape)

# """Perform KNN using the vector obtained in the previous step. Following are the steps to be followed:

# 1. Normalise the vectors
# 2. Split the data into training and test to estimate the performance.
# 3. Fit the Nearest Neughbiurs module to the training data and obtain the predicted class by getting the nearest neighbours on the test data.
# 4. Report the accuracy, chosen k-value and method used to obtain the predicted class. Hint: Plot accuracies for a range of k-values.
# """

# your code here
X = normalize(X)
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=37)
print(len(X_train), len(X_test))

knn = KNN()
knn.fit(X_train, y_train)

y_pred = knn.predict(X_test)
acc = accuracy_score(y_test, y_pred)
acc

# """### experimenting with values of k"""

k = np.arange(1,50)
accuracy = list()
for i in k:
    knn = KNN(k = i)
    knn.fit(X_train, y_train)
    y_pred = knn.predict(X_test)
    acc = accuracy_score(y_test, y_pred)
    accuracy.append(acc)
    
plt.plot(k, accuracy)
plt.xLabel('K')
plt.yLabel('Accuracy')
plt.show()

# """### Subpart-2

# Explain the differences between the accuracies obtained in each part above based on the features used.
# """